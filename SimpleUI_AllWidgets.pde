// Example programme showing the SimpleUIManager (declared in the SimpleUI_Classes tab)
// This is for version 1, where only Menus and Simple Buttons are possible
//
//
//

SimpleUIManager uiManager;
Document document;
String toolMode = "";
PImage backgroundImage = null; 

PImage sourceImage;
int imageWidth, imageHeight;
int isContrastOrBrightness = 0;

PImage img;
PImage imgEnhanced;

void setup() {
  size(900,900);
 
  int top = 5;
  uiManager = new SimpleUIManager();
  document = new Document();
  
  String[] menu1Items =  { "Load Image", "Save Image", "Black White", "Grey Scale","ContrastBrightness", "Posterize","Erode","Opaque","Invert","Blur Filter", "Sharpen Filter","Edge Filter" };
  String[] menu2Items =  { "rect", "line", "ellipse","bugsbunny","thing5","thing6" };
  String[] menu3Items =  { "fish", "cat", "dog","hen","verycutebunny","uglypug" };
  String[] menu4Items =  { "fish", "cat", "dog","hen","verycutebunny","uglypug" };
  uiManager.addMenu("Image Processing", 100, top, menu1Items);
  uiManager.addMenu("Drawing Shapes", 185, top, menu2Items);
  uiManager.addMenu("UI File IO", 270, top, menu3Items);
  uiManager.addMenu("Strech Goals", 355, top, menu4Items);
  
  uiManager.addSimpleButton("greyscale", 100, 50);
  uiManager.addSimpleButton("but 2", 180, 50);
  
  
  uiManager.addToggleButton("toggle 1", 320, 50);
  uiManager.addToggleButton("toggle 2", 380, 50);
  
  SimpleButton  rectButton = uiManager.addRadioButton("rect", 5, 5, "group1");
  uiManager.addRadioButton("line", 5, 55, "group1");
  uiManager.addRadioButton("ellipse", 5, 110, "group1");
  uiManager.addRadioButton("curve", 5, 165, "group1");
  uiManager.addRadioButton("select", 5, 230, "group1");
  uiManager.addRadioButton("something", 5, 285, "group1");
  
  rectButton.selected = true;
 
  
  uiManager.addSlider("size", 600,10, true);
  uiManager.addSlider("brightness", 600,40, true);
  
  uiManager.addCanvas(100,100,870,450);
  //image(sourceImage, 100,100,350,350);
}

/*void settings(){
  sourceImage = loadImage("image1.jpg");
  imageWidth = sourceImage.width;
  imageHeight = sourceImage.height;
  size(imageWidth*2, imageHeight);
  
}*/

void draw() {


   //Clears the screen to remove repeatedly drawn shapes
   background(g.backgroundColor);
   
   // draw any graphics before the user-interface
  if(this.backgroundImage != null){
    image(backgroundImage, 100,100,350,350);    
   }
   
   if(isContrastOrBrightness == 1){
      img = this.backgroundImage;
      imgEnhanced = new PImage(img.width, img.height); 
      //contrast - this probably doesn't need to be bigger than 5 or 10
      float contrast = 5f * ( mouseX / (float)width); //value should go from 0 to 5
      println("contrast: " + contrast);
      
      //brightness - this is additive and we want to make it both brigher and darker so -128 to +128
      float bright = 255 * ( mouseY / (float)width  - 0.5); //value should go from -128 to +128
      println("bright: " + bright);
      ContrastAndBrightness(img,imgEnhanced, contrast,bright); 
      
      //display the image
      //image(img, 100,100,350,350);
      image(imgEnhanced, 500,100,350,350);
   }
   
   // update and draw the user interface
    document.drawMe();
   uiManager.drawMe();
   
   
      
}

void mousePressed(){
  uiManager.handleMouseEvent("mousePressed",mouseX,mouseY);
}

void mouseReleased(){
  uiManager.handleMouseEvent("mouseReleased",mouseX,mouseY);
}

void mouseClicked(){
  uiManager.handleMouseEvent("mouseClicked",mouseX,mouseY);
}

void mouseMoved(){
    uiManager.handleMouseEvent("mouseMoved",mouseX,mouseY);
}

void mouseDragged(){
   uiManager.handleMouseEvent("mouseDragged",mouseX,mouseY);
}

void simpleUICallback(UIEventData eventData){
  // first boolean is for extra data, second boolean is to show mouseMoves, which you might not want
  eventData.printMe(true, false);
  switch(eventData.uiLabel) {
     case "ContrastBrightness":
         isContrastOrBrightness = 1; 
         break;
     
     case "size":
              isContrastOrBrightness = 0;
                       
      break;
     case "Load Image":
             isContrastOrBrightness = 0;
            // This is generated by a menu
            // opens a file load dialogue, 
            // whenan image is selectd it then calls
            // the function "loadAnImage()" written juat below here
            selectInput("Open image", "loadAnImage");
            break;
     case "Save Image":
               isContrastOrBrightness = 0;
               image(this.backgroundImage, 0, 0);
               this.backgroundImage.save("Apple.jpg");
    break;
    case "Black White":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(THRESHOLD,0.8);
    break;
    case "Grey Scale":
              isContrastOrBrightness = 0;
              //PImage myImage11 = this.backgroundImage;
              img = this.backgroundImage;
              imgEnhanced = new PImage(img.width, img.height); 
              convertGray(img,imgEnhanced);    
              //display the image
              image(imgEnhanced, 500,100,350,350);
    break;
    case "Blur":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(BLUR, 6);
    break;
    case "Sharpen":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(POSTERIZE, 255);
    break;
    case "Posterize":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(POSTERIZE, 4);
    break;
    case "Erode":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(ERODE);
    break;
    case "Opaque":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(OPAQUE);
    break;
    case "Invert":
              isContrastOrBrightness = 0;
             img = this.backgroundImage;
             imgEnhanced =img;// new PImage(img.width, img.height); 
             //convertBW(img,imgEnhanced);
             //display the image
             image(imgEnhanced, 500,100,350,350);
             filter(INVERT);
    break;
    case "Blur Filter":
              isContrastOrBrightness = 0;
              PImage blurImage = this.backgroundImage;
              imageWidth = blurImage.width;
              imageHeight = blurImage.height;
              //image(edgeImage, 0, 0);
              PImage bOutputImage = createImage(blurImage.width*2,blurImage.height,RGB);
              blurImage.loadPixels();
              bOutputImage.loadPixels();
  
              int matrixSize = 3;
              for(int y = 0; y < imageHeight; y++){
                for(int x = 0; x < imageWidth; x++){    
                color c = convolution(x, y, blur_matrix, matrixSize, blurImage);                
                bOutputImage.set(x,y,c);    
                }
              }             
             blurImage.updatePixels();
             bOutputImage.updatePixels();
             image(bOutputImage, 500,100,725,350);
    break;
    case "Sharpen Filter":
              isContrastOrBrightness = 0;
              PImage sharpImage = this.backgroundImage;
              imageWidth = sharpImage.width;
              imageHeight = sharpImage.height;
              //image(edgeImage, 0, 0);
              PImage sharpOutputImage = createImage(sharpImage.width*2,sharpImage.height,RGB);
              sharpImage.loadPixels();
              sharpOutputImage.loadPixels();
  
              int sMatrixSize = 3;
              for(int y = 0; y < imageHeight; y++){
                for(int x = 0; x < imageWidth; x++){    
                color c = convolution(x, y, sharpen_matrix, sMatrixSize, sharpImage);                
                sharpOutputImage.set(x,y,c);    
                }
              }             
             sharpImage.updatePixels();
             sharpOutputImage.updatePixels();
              image(sharpOutputImage, 500,100,725,350);
    break;
    case "Edge Filter":
              isContrastOrBrightness = 0;
              PImage edgeImage = this.backgroundImage;
              imageWidth = edgeImage.width;
              imageHeight = edgeImage.height;
              //image(edgeImage, 0, 0);
              PImage eOutputImage = createImage(edgeImage.width*2,edgeImage.height,RGB);
              edgeImage.loadPixels();
              eOutputImage.loadPixels();
  
              int eMatrixSize = 3;
              for(int y = 0; y < imageHeight; y++){
                for(int x = 0; x < imageWidth; x++){    
                color c = convolution(x, y, edge_matrix, eMatrixSize, edgeImage);                
                eOutputImage.set(x,y,c);    
                }
              }             
             edgeImage.updatePixels();
             eOutputImage.updatePixels();
              image(eOutputImage, 500,100,725,350);
    break;     
    case "greyscale":
             background(175,175,175);
    break;
         
     
    /*case "quit":
               exit(); 
    break; */
  }
  
 if(eventData.uiComponentType == "RadioButton")
  {
    toolMode = eventData.uiLabel;
  }

  if(eventData.uiComponentType != "Canvas") return;
    
  switch(toolMode) 
  {
          case "rect": 
            drawRect(eventData);
            break;
            
          case "line": 
            drawLine(eventData);
            break;
          
          case "ellipse":
            drawEllipse(eventData);
            break;
          
          case "select": 
            trySelection(eventData);
            break;
            //..... other tools here
            

            //..... other tools here
  }
 
}

//Converts chosen image into black and white. 
void convertBW(PImage myImage, PImage imgEnhanced)
{
  for (int y = 0; y < imgEnhanced.height; y++)
   {
     for (int x = 0; x < imgEnhanced.width; x++)
     {
        color thisPix = myImage.get(x,y);
        
        int r = (int) red(thisPix);
        int g = (int) green(thisPix);
        int b = (int) blue(thisPix);
        color newColour = color((r+g+b)/2);
        imgEnhanced.set(x,y, newColour);  
    }  
  }
  filter(THRESHOLD,0.7);
}

//Converts chosen image into grey scale. 
void convertGray(PImage myImage1, PImage imgEnhanced)
{
   for (int y = 0; y < imgEnhanced.height; y++)
   {
     for (int x = 0; x < imgEnhanced.width; x++)
     {
        color thisPix = myImage1.get(x,y);
        
        int r = (int) red(thisPix);
        int g = (int) green(thisPix);
        int b = (int) blue(thisPix);
        color newColour = color((r+g+b)/3);
        imgEnhanced.set(x,y, newColour);  
    }  
  }
}

//Function to load an image. 
void loadAnImage(File fileNameObj){
  String pathAndFileName = fileNameObj.getAbsolutePath();
  PImage sourceImage = loadImage(pathAndFileName); 
  imageWidth = sourceImage.width;
  imageHeight = sourceImage.height;
  //size(imageWidth*2, imageHeight);
  this.backgroundImage = sourceImage;
  
  
}


float[][] edge_matrix = { { 0,  -2,  0 },
                          { -2,  8, -2 },
                          { 0,  -2,  0 } }; 
                     
float[][] blur_matrix = {  {0.1,  0.1,  0.1 },
                           {0.1,  0.1,  0.1 },
                           {0.1,  0.1,  0.1 } };                      

float[][] sharpen_matrix = {  { 0, -1, 0 },
                              {-1, 5, -1 },
                              { 0, -1, 0 } };  

color convolution(int x, int y, float[][] matrix, int matrixsize, PImage img)
{
  float rtotal = 0.0;
  float gtotal = 0.0;
  float btotal = 0.0;
  int offset = matrixsize / 2;
  for (int i = 0; i < matrixsize; i++){
    for (int j= 0; j < matrixsize; j++){
      // What pixel are we testing
      int xloc = x+i-offset;
      int yloc = y+j-offset;
      int loc = xloc + img.width*yloc;
      // Make sure we haven't walked off our image, we could do better here
      loc = constrain(loc,0,img.pixels.length-1);
      // Calculate the convolution
      rtotal += (red(img.pixels[loc]) * matrix[i][j]);
      gtotal += (green(img.pixels[loc]) * matrix[i][j]);
      btotal += (blue(img.pixels[loc]) * matrix[i][j]);
    }
  }
  // Make sure RGB is within range
  rtotal = constrain(rtotal, 0, 255);
  gtotal = constrain(gtotal, 0, 255);
  btotal = constrain(btotal, 0, 255);
  // Return the resulting color
  return color(rtotal, gtotal, btotal);
}

//image processing function to enhance contrast
//this doesn't make sense without also adjusting the brightness at the same time
void ContrastAndBrightness(PImage input, PImage output,float cont,float bright)
{
   int w = input.width;
   int h = input.height;
   println("w: " + w + " h: "+h);
   //our assumption is the image sizes are the same
   //so test this here and if it's not true just return with a warning
   if(w != output.width || h != output.height)
   {
     println("error: image dimensions must agree");
     return;
   }
   
   //this is required before manipulating the image pixels directly
   input.loadPixels();
   output.loadPixels();
      
   //loop through all pixels in the image
   for(int i = 0; i < w*h; i++)
   {  
       //get color values from the current pixel (which are stored as a list of type 'color')
       color inColor = input.pixels[i];
       
       //slow version for illustration purposes - calling a function inside this loop
       //is a big no no, it will be very slow, plust we need an extra cast
       //as this loop is being called w * h times, that can be a million times or more!
       //so comment this version and use the one below
      // int r = (int) red(input.pixels[i]);
      // int g = (int) green(input.pixels[i]);
      // int b = (int) blue(input.pixels[i]);
       
       //here the much faster version (uses bit-shifting) - uncomment to try
       int r = (inColor >> 16) & 0xFF; //like calling the function red(), but faster
       int g = (inColor >> 8) & 0xFF;
       int b = inColor & 0xFF;      
       
       //apply contrast (multiplcation) and brightness (addition)
       r = (int)(r * cont + bright); //floating point aritmetic so convert back to int with a cast (i.e. '(int)');
       g = (int)(g * cont + bright);
       b = (int)(b * cont + bright);
       
       //slow but absolutely essential - check that we don't overflow (i.e. r,g and b must be in the range of 0 to 255)
       //to explain: this nest two statements, sperately it would be r = r < 0 ? 0 : r; and r = r > 255 ? 255 : 0;
       //you can also do this with if statements and it would do the same just take up more space
       //r = r < 0 ? 0 : r > 255 ? 255 : r;
       //g = g < 0 ? 0 : g > 255 ? 255 : g;
       //b = b < 0 ? 0 : b > 255 ? 255 : b;
       
       //and again in reverse for illustration - calling the color function is slow so use the bit-shifting version below
       output.pixels[i] = color(r,g,b);
       //output.pixels[i]= 0xff000000 | (r << 16) | (g << 8) | b; //this does the same but faster
   
   }
   
   //so that we can display the new image we must call this for each image
   input.updatePixels();
   output.updatePixels();
}

void drawRect(UIEventData eventData)
{
  PVector p = new PVector(eventData.mousex, eventData.mousey);
  if(eventData.mouseEventType == "mousePressed")
  {
    // start the rect here
    document.startNewShape("rect", p);
  }
  
  if(eventData.mouseEventType == "mouseDragged")
  {
    // end the rect here
    if( document.currentlyDrawnShape == null ) return;
    document.currentlyDrawnShape.duringMouseDrawing(p);
  }
  
  if(eventData.mouseEventType == "mouseReleased")
  {
    // end the rect here
    if( document.currentlyDrawnShape == null ) return;
    document.currentlyDrawnShape.endMouseDrawing(p);
    document.currentlyDrawnShape  = null;
  }
}

void drawLine(UIEventData eventData)
{
  PVector p = new PVector(eventData.mousex, eventData.mousey);
  if(eventData.mouseEventType == "mousePressed")
  {
    // start the line here
    document.startNewShape("line", p);
  }
  
  if(eventData.mouseEventType == "mouseDragged")
  {
    // end the line here
    if( document.currentlyDrawnShape == null ) return;
    document.currentlyDrawnShape.duringMouseDrawing(p);
  }
  
  if(eventData.mouseEventType == "mouseReleased")
  {
    // end the line here
    if( document.currentlyDrawnShape == null ) return;
    document.currentlyDrawnShape.endMouseDrawing(p);
    document.currentlyDrawnShape  = null;
  }
}


void drawEllipse(UIEventData eventData)
{
  PVector p = new PVector(eventData.mousex, eventData.mousey);
  if(eventData.mouseEventType == "mousePressed")
  {
    // start the Ellipse here
    document.startNewShape("ellipse", p);
  }
  
  if(eventData.mouseEventType == "mouseDragged")
  {
    // end the Ellipse here
    if( document.currentlyDrawnShape == null ) return;
    document.currentlyDrawnShape.duringMouseDrawing(p);
  }
  
  if(eventData.mouseEventType == "mouseReleased")
  {
    // end the Ellipse here
    if( document.currentlyDrawnShape == null ) return;
    document.currentlyDrawnShape.endMouseDrawing(p);
    document.currentlyDrawnShape  = null;
  }
}

void trySelection(UIEventData eventData){
  if(eventData.mouseEventType != "mousePressed") return;
  
  PVector p = new PVector(eventData.mousex,eventData.mousey);
  document.trySelect(p);
  
  
}
